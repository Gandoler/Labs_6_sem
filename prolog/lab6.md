# лаб 6

## Введение

Для получения полной оценки не забывайте про тесты. Два варианта тестирования:

1. Определите предикат `test` без аргументов, который выполняется, если все тесты проходят. Этот подход достаточно ограничен по возможностям.
   Пример:
   ```prolog
   test_my_last :-
       my_last(1, [3,2,1]),
       \+ my_last(1, []). %% \+ означает "не".

   test :-
       test_my_last, ...
   ```

2. (Предпочтительно) используйте стандартную библиотеку PlUnit (http://www.swiprolog.org/pldoc/package/plunit.html). Можно использовать предикаты из стандартной библиотеки. Рекомендуется также прочитать http://www.cse.unsw.edu.au/~billw/testing.html.

## Задание 1: Постройте деревья вызова для запросов

### Запросы

1. `?- предок_потомок(алексей, X).` %% family.pl

```prolog
% family.pl
родитель(алексей, иван).
родитель(иван, петр).
предок_потомок(X, Y) :- родитель(X, Y).
предок_потомок(X, Y) :- родитель(X, Z), предок_потомок(Z, Y).
```
```
предок_потомок(алексей, X)
    ├── родитель(алексей, X) → X = иван
    └── родитель(алексей, Z), предок_потомок(Z, X)
            ├── Z = иван
            └── предок_потомок(иван, X)
                    ├── родитель(иван, X) → X = петр
                    └── родитель(иван, Z1), предок_потомок(Z1, X)
                            ├── Z1 = петр
                            └── предок_потомок(петр, X)
                                    ├── родитель(петр, X) → Fail
                                    └── родитель(петр, Z2), предок_потомок(Z2, X) → Fail

```

   <img width="1088" alt="image" src="https://github.com/user-attachments/assets/c005adc0-50fc-4660-90ac-98e4f16c2519" />

Первый уровень:

Prolog проверяет, является ли X прямым потомком алексей. Находит X = иван.

Второй уровень:

Prolog ищет непрямых потомков. Он находит, что иван является родителем петр, и возвращает X = петр.

Третий уровень:

Prolog пытается найти потомков петр, но не находит их, так как петр не имеет потомков.



3. `?- my_append([a,b,c], List, [Head | Tail]).` %% lists.pl

## Задание 2: Предикат `starts_with(List1, List2)`

Задайте предикат `starts_with(List1, List2)`, который успешен, если `List2` -- начальная часть `List1`.

Примеры работы
1. Проверяем, что [1, 2, 3, 4] начинается с [1, 2]
```prolog
?- starts_with([1,2,3,4], [1,2]).
```
Развернём шаги рекурсии:

[1|[2,3,4]] и [1|[2]] → Головы равны (1 = 1), вызываем starts_with([2,3,4], [2])
[2|[3,4]] и [2|[]] → Головы равны (2 = 2), вызываем starts_with([3,4], [])
Пустой список [] всегда является началом любого списка, значит, срабатывает базовый случай starts_with(_, []).
Результат: true.

```prolog
starts_with(_, []).
starts_with([H|T1], [H|T2]) :- starts_with(T1, T2).
```
<img width="777" alt="image" src="https://github.com/user-attachments/assets/477a1f9a-7e58-4abb-93ff-f50388c0daa5" />


Пример:
```prolog
starts_with([1,2,3], [1,2]).
```
Проверьте поведение, если переменные на других местах.

## Задание 3: Предикат `replace(List, Member, Replacement, ResultList)`

Задайте предикат `replace(List, Member, Replacement, ResultList)`. `ResultList` должен быть результатом замены всех вхождений терма `Member` в `List` на `Replacement`.


```prolog
% Базовый случай: если список пуст, заменять нечего, возвращаем пустой список.
replace([], _, _, []).

% Если голова списка равна заменяемому элементу, заменяем её на Replacement
% и рекурсивно обрабатываем оставшуюся часть списка.
replace([Member|T], Member, Replacement, [Replacement|NewT]) :-
    replace(T, Member, Replacement, NewT).

% Если голова списка не равна заменяемому элементу, оставляем её без изменений
% и рекурсивно обрабатываем оставшуюся часть списка.
replace([H|T], Member, Replacement, [H|NewT]) :-
    H \= Member,  % Проверяем, что H не равно Member
    replace(T, Member, Replacement, NewT).
```


<img width="778" alt="image" src="https://github.com/user-attachments/assets/ab754e94-e42d-4d9d-985e-7e701a2407b7" />

Пример:
```prolog
replace([1,2,3,1,2,3], 1, 5, X).
```


## Задание 4: Предикат `my_flatten(NestedList, FlattenedList)`

Определите предикат `my_flatten(NestedList, FlattenedList)`, "расплющивающий" вложенный список `NestedList`.


```prolog
% Базовый случай: если список пуст, то результат тоже пуст.
my_flatten([], []).  

% Если голова списка (H) является списком, разворачиваем его рекурсивно,
% затем разворачиваем хвост (T), после чего объединяем оба результата.
my_flatten([H|T], FlatList) :-  
    is_list(H),                 % Проверяем, является ли H списком  
    my_flatten(H, FlatH),       % Рекурсивно разворачиваем H  
    my_flatten(T, FlatT),       % Разворачиваем хвост T  
    append(FlatH, FlatT, FlatList). % Объединяем оба результата в один список  

% Если H — не список, просто добавляем его в итоговый список  
% и продолжаем разворачивать хвост.
my_flatten([H|T], [H|FlatT]) :-  
    \+ is_list(H),              % Проверяем, что H НЕ является списком  
    my_flatten(T, FlatT).       % Продолжаем обработку хвоста  
```

<img width="842" alt="image" src="https://github.com/user-attachments/assets/f4e721d8-3163-48d2-90b7-8a13e46e3849" />

Пример:
```prolog
my_flatten([1, [2, [3, 4], 5]], X).
```

## Задание 5: Код Грея

Код Грея для n бит -- список всех возможных списков 0 и 1 длины n, два соседних списка в котором отличаются только в одном месте. Он может быть рекурсивно построен на основе кода для n–1 бит следующим алгоритмом:

1. переворачиваем исходный список.
2. дописываем 0 в начало каждого кода в исходном списке
3. дописываем 1 в начало кодов в перевёрнутом списке.
4. объединяем оба полученных списка.

Например, для генерации списка для 3 бит:
0. Коды для 2 бит: 00, 01, 11, 10
1. Перевёрнутый список кодов: 10, 11, 01, 00
2. К начальному списку дописаны нули: 000, 001, 011, 010
3. К перевёрнутому списку дописаны единицы: 110, 111, 101, 100
4. Объединённый список: 000, 001, 011, 010, 110, 111, 101, 100


Базовый случай: если список содержит только один элемент, возможные коды — [[0], [1]].
Рекурсия: строим код Грея для N-1 бит, затем:
Переворачиваем полученный список.
К исходному списку кодов добавляем 0 в начало каждого элемента.
К перевернутому списку кодов добавляем 1 в начало каждого элемента.
Объединяем оба списка, получая код Грея для N бит.
В результате получается список, где каждый следующий элемент отличается от предыдущего только одним битом.

Задайте предикат `gray(L, Code)`, возвращающий в `Code` код Грея для N бит, где N -- длина списка L.

```prolog
% Базовый случай: для списка длины 1 (один бит) возможны только два кода: 0 и 1.
gray([_], [[0], [1]]).

% Рекурсивный случай: строим код Грея для списка длины N на основе кода для N-1.
gray(L, Code) :-
    length(L, N),  % Определяем длину входного списка
    N1 is N - 1,   % Вычисляем длину для рекурсивного вызова
    length(L1, N1), % Создаем новый список длины N-1
    gray(L1, Code1), % Рекурсивно получаем код Грея для N-1 бит
    reverse(Code1, Reversed), % Переворачиваем полученный код

    % Добавляем 0 в начало каждого кода в исходном списке
    maplist(append([0]), Code1, Zeros),

    % Добавляем 1 в начало каждого кода в перевёрнутом списке
    maplist(append([1]), Reversed, Ones),

    % Объединяем оба списка в один
    append(Zeros, Ones, Code).

```


<img width="748" alt="image" src="https://github.com/user-attachments/assets/35972b71-8df1-457c-b347-83ab133b1f65" />

Примеры:
```prolog
?- gray([0], Code).
Code = [[0], [1]]. %% 1 бит

?- gray([0,0], Code).
Code = [[0,0], [0,1], [1,1], [1,0]]. %% 2 бит
```

