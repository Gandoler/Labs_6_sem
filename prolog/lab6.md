# лаб 6

## Введение

Для получения полной оценки не забывайте про тесты. Два варианта тестирования:

1. Определите предикат `test` без аргументов, который выполняется, если все тесты проходят. Этот подход достаточно ограничен по возможностям.
   Пример:
   ```prolog
   test_my_last :-
       my_last(1, [3,2,1]),
       \+ my_last(1, []). %% \+ означает "не".

   test :-
       test_my_last, ...
   ```

2. (Предпочтительно) используйте стандартную библиотеку PlUnit (http://www.swiprolog.org/pldoc/package/plunit.html). Можно использовать предикаты из стандартной библиотеки. Рекомендуется также прочитать http://www.cse.unsw.edu.au/~billw/testing.html.

## Задание 1: Постройте деревья вызова для запросов

### Запросы

1. `?- предок_потомок(алексей, X).` %% family.pl

```prolog
% family.pl
родитель(алексей, иван).
родитель(иван, петр).
предок_потомок(X, Y) :- родитель(X, Y).
предок_потомок(X, Y) :- родитель(X, Z), предок_потомок(Z, Y).
```
```
предок_потомок(алексей, X)
    ├── родитель(алексей, X) → X = иван
    └── родитель(алексей, Z), предок_потомок(Z, X)
            ├── Z = иван
            └── предок_потомок(иван, X)
                    ├── родитель(иван, X) → X = петр
                    └── родитель(иван, Z1), предок_потомок(Z1, X)
                            ├── Z1 = петр
                            └── предок_потомок(петр, X)
                                    ├── родитель(петр, X) → Fail
                                    └── родитель(петр, Z2), предок_потомок(Z2, X) → Fail

```

   <img width="1088" alt="image" src="https://github.com/user-attachments/assets/c005adc0-50fc-4660-90ac-98e4f16c2519" />

Первый уровень:

Prolog проверяет, является ли X прямым потомком алексей. Находит X = иван.

Второй уровень:

Prolog ищет непрямых потомков. Он находит, что иван является родителем петр, и возвращает X = петр.

Третий уровень:

Prolog пытается найти потомков петр, но не находит их, так как петр не имеет потомков.



3. `?- my_append([a,b,c], List, [Head | Tail]).` %% lists.pl

## Задание 2: Предикат `starts_with(List1, List2)`

Задайте предикат `starts_with(List1, List2)`, который успешен, если `List2` -- начальная часть `List1`.

Пример:
```prolog
?- starts_with([a,b,c], X).
X = [a, b];
X = [a];
X = [].
```
Проверьте поведение, если переменные на других местах.

## Задание 3: Предикат `replace(List, Member, Replacement, ResultList)`

Задайте предикат `replace(List, Member, Replacement, ResultList)`. `ResultList` должен быть результатом замены всех вхождений терма `Member` в `List` на `Replacement`.

Пример:
```prolog
?- replace([1,2,3,1,2,3], 1, 5, X).
X = [1, 2, 5, 1, 2, 5].
```
Проверьте поведение, если переменные на других местах.

## Задание 4: Предикат `my_flatten(NestedList, FlattenedList)`

Определите предикат `my_flatten(NestedList, FlattenedList)`, "расплющивающий" вложенный список `NestedList`.

Пример:
```prolog
?- my_flatten([a, [[b], c], [[d]]], X).
X = [a, b, c, d].
```

## Задание 5: Код Грея

Код Грея для n бит -- список всех возможных списков 0 и 1 длины n, два соседних списка в котором отличаются только в одном месте. Он может быть рекурсивно построен на основе кода для n–1 бит следующим алгоритмом:

1. переворачиваем исходный список.
2. дописываем 0 в начало каждого кода в исходном списке
3. дописываем 1 в начало кодов в перевёрнутом списке.
4. объединяем оба полученных списка.

Например, для генерации списка для 3 бит:
0. Коды для 2 бит: 00, 01, 11, 10
1. Перевёрнутый список кодов: 10, 11, 01, 00
2. К начальному списку дописаны нули: 000, 001, 011, 010
3. К перевёрнутому списку дописаны единицы: 110, 111, 101, 100
4. Объединённый список: 000, 001, 011, 010, 110, 111, 101, 100

Задайте предикат `gray(L, Code)`, возвращающий в `Code` код Грея для N бит, где N -- длина списка L.

Примеры:
```prolog
?- gray([0], Code).
Code = [[0], [1]]. %% 1 бит

?- gray([0,0], Code).
Code = [[0,0], [0,1], [1,1], [1,0]]. %% 2 бит
```

