
# Лабораторная работа 7



## Разбор операторов =, ==, =:= и is

Чтобы разобраться с различиями операторов `=`, `==`, `=:=` и `is`, для каждого запроса сначала попытайтесь понять, как должен ответить Пролог, а потом проверьте, правильны ли ваши предположения.

### Запросы

Два терма унифицируются, если их можно сделать одинаковыми, подставляя значения переменным.

- `?- X = 1+2.`       X унифицируется с термом 1+2, X = 1+2.
- `?- 3 = 1+2.`       3 не унифицируется с 1+2, false.
- `?- 2+1 = 1+2.`     2+1 не унифицируется с 1+2, false.
- `?- X == 1+2.`      X не идентичен терму 1+2, false.
- `?- 3 == 1+2.`      3 не идентичен терму 1+2, false.
- `?- 2+1 == 1+2.`    2+1 не идентичен 1+2, false.
- `?- X =:= 1+2.`     X должен быть числом, равным 3, но X не определен, ошибка. 
- `?- 3 =:= 1+2.`     3 равно 3, true. 
- `?- 2+1 =:= 1+2.`   3 равно 3, true. 
- `?- X is 1+2.`      X вычисляется как 3, X = 3.
- `?- 3 is 1+2.`      3 равно 3, true.
- `?- 2+1 is 1+2.`    3 равно 3, true.

## Предикаты проверки типов

- `var(Term)` -- удаётся для свободных переменных
- `nonvar(Term)` -- противоположный `var`
- `float(Term)` -- удаётся для чисел с плавающей точкой
- `integer(Term)` -- удаётся для целых чисел
- `number(Term)` -- удаётся для любых чисел
- `atom(Term)` -- удаётся для атомов 
- `compound(Term)` -- удаётся для составных термов
- `atomic(Term)` -- удаётся, если Term -- атом или число (или значение встроенного типа "строка", который в нашем курсе не используется)
- `callable(Term)` -- удаётся, если Term -- атом или составной терм
- `ground(Term)` -- удаётся, если Term не содержит свободных переменных 

## Задание 1: Определение предиката `factorial(N, FactN)`

Определите предикат `factorial(N, FactN)`, который выполняется, если `FactN` -- факториал `N`.


```prolog
factorial(0, 1).
factorial(N, FactN) :-
    N > 0,
    N1 is N - 1,
    factorial(N1, FactN1),
    FactN is N * FactN1.
```

<img width="574" alt="image" src="https://github.com/user-attachments/assets/22773ccf-f3e2-45d0-971f-588eec95103e" />


Запрос: factorial(3, Fact).

N = 3, условие N > 0 выполняется.
Вычисляем N1 = 3 - 1 = 2.
Вызываем factorial(2, FactN1).
Запрос: factorial(2, FactN1).

N = 2, условие N > 0 выполняется.
Вычисляем N1 = 2 - 1 = 1.
Вызываем factorial(1, FactN1).
Запрос: factorial(1, FactN1).

N = 1, условие N > 0 выполняется.
Вычисляем N1 = 1 - 1 = 0.
Вызываем factorial(0, FactN1).
Запрос: factorial(0, FactN1).

Это базовый случай, который возвращает FactN1 = 1.
Теперь начинается возврат значений по цепочке:

factorial(1, Fact1): Fact1 = 1 * 1 = 1
factorial(2, Fact2): Fact2 = 2 * 1 = 2
factorial(3, Fact3): Fact3 = 3 * 2 = 6
Ответ: Fact = 6.

## Задание 2: Определение предиката `occurrences(Elem, List, Number)`

Определите предикат `occurrences(Elem, List, Number)`, который выполняется, если элемент `Elem` встречается в списке `List` `Number` раз.


```prolog
occurrences(_, [], 0).
occurrences(Elem, [Elem|Tail], N) :-
    occurrences(Elem, Tail, N1),
    N is N1 + 1.
occurrences(Elem, [Head|Tail], N) :-
    Elem \= Head,
    occurrences(Elem, Tail, N).
```

<img width="685" alt="image" src="https://github.com/user-attachments/assets/cb1ddbb5-e78c-49d7-8bf1-521608f70f86" />


#### **Пример 1: `occurrences(a, [a, b, a], N).`**
- `List = [a, b, a]`, `Elem = a`
1. `a == a` → рекурсивный вызов `occurrences(a, [b, a], N1)`, `N is N1 + 1`
2. `b \= a` → рекурсивный вызов `occurrences(a, [a], N2)`, `N2 = N1`
3. `a == a` → рекурсивный вызов `occurrences(a, [], N3)`, `N3 = 0`
4. Базовый случай → `N3 = 0`
5. Поднятие вверх:  
   - `N2 = 0 + 1 = 1`
   - `N1 = 1 + 1 = 2`
   - `N = 2`

Пример 1: occurrences(a, [a, b, a], N).
List = [a, b, a], Elem = a
a == a → рекурсивный вызов occurrences(a, [b, a], N1), N is N1 + 1
b \= a → рекурсивный вызов occurrences(a, [a], N2), N2 = N1
a == a → рекурсивный вызов occurrences(a, [], N3), N3 = 0
Базовый случай → N3 = 0
Поднятие вверх:
N2 = 0 + 1 = 1
N1 = 1 + 1 = 2
N = 2


## Задание 3: Определение предиката `rule(Rule)`

Определите предикат `rule(Rule)`, который проверяет, является ли терм `Rule` правилом (без точки в конце), то есть: 1. Голова правила может быть вызвана (в смысле `callable/1`); 2. Тело правила состоит из (1 или более) callable термов, разделённых ',' и ';' (заметьте, что `T1,T2` и `T1;T2` -- сами callable, но их нужно обрабатывать отдельно).

Примеры:
```prolog
?- rule(p(X, Y) :- q(X)).
Yes
?- rule(p :- q(X), r, r).
Yes
?- rule(4 :- p, q).
No
?- rule(p :- 4, q).
No
```

## Задание 4: Определение предиката `eval_arithmetic(Expr, Values, Result)`

Определите предикат `eval_arithmetic(Expr, Values, Result)`, который выполняется, если `Expr` -- арифметическое выражение (содержащее операторы +, *, -, / и атомы в качестве переменных), `Values` -- список термов `Var = Val`, где `Var` -- атом, а `Val` -- число, а `Result` -- результат вычисления `Expr` при подстановке вместо каждого атома соответствующего ему значения из `Values`. 

Пример:
```prolog
?- eval_arithmetic(x + 3*y, [x = 2, y = 1], Result).
Result = 5
```

## Задание 5: Определение предиката `prime_factors(Num, Factors)`

Определите предикат `prime_factors(Num, Factors)`, находящий все простые делители числа `Num` и их кратность.

Пример:
```prolog
?- prime_factors(315, L).
L = [factor(3,2),factor(5,1),factor(7,1)] %% означает, что 315 = 3^2 * 5^1 * 7^1
```

## Задание 6: Определение предиката `polynomize(Expr, Poly)`

Определите предикат `polynomize(Expr, Poly)`, который выполняется, если `Expr` -- арифметическое выражение (включающее операции +, *, ^ в константную степень), а `Poly` -- многочлен в нормальной форме (см. 1.3), получающийся в результате его упрощения.

Пример:
```prolog
?- polynomize((x + x)*(x + 1), Poly).
Poly = 2*x^2 + 2*x
```

