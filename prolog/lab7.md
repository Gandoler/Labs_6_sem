
# Лабораторная работа 7



## Разбор операторов =, ==, =:= и is

Чтобы разобраться с различиями операторов `=`, `==`, `=:=` и `is`, для каждого запроса сначала попытайтесь понять, как должен ответить Пролог, а потом проверьте, правильны ли ваши предположения.

### Запросы

Два терма унифицируются, если их можно сделать одинаковыми, подставляя значения переменным.

- `?- X = 1+2.`       X унифицируется с термом 1+2, X = 1+2.
- `?- 3 = 1+2.`       3 не унифицируется с 1+2, false.
- `?- 2+1 = 1+2.`     2+1 не унифицируется с 1+2, false.
- `?- X == 1+2.`      X не идентичен терму 1+2, false.
- `?- 3 == 1+2.`      3 не идентичен терму 1+2, false.
- `?- 2+1 == 1+2.`    2+1 не идентичен 1+2, false.
- `?- X =:= 1+2.`     X должен быть числом, равным 3, но X не определен, ошибка. 
- `?- 3 =:= 1+2.`     3 равно 3, true. 
- `?- 2+1 =:= 1+2.`   3 равно 3, true. 
- `?- X is 1+2.`      X вычисляется как 3, X = 3.
- `?- 3 is 1+2.`      3 равно 3, true.
- `?- 2+1 is 1+2.`    3 равно 3, true.

## Предикаты проверки типов

- `var(Term)` -- удаётся для свободных переменных
- `nonvar(Term)` -- противоположный `var`
- `float(Term)` -- удаётся для чисел с плавающей точкой
- `integer(Term)` -- удаётся для целых чисел
- `number(Term)` -- удаётся для любых чисел
- `atom(Term)` -- удаётся для атомов 
- `compound(Term)` -- удаётся для составных термов
- `atomic(Term)` -- удаётся, если Term -- атом или число (или значение встроенного типа "строка", который в нашем курсе не используется)
- `callable(Term)` -- удаётся, если Term -- атом или составной терм
- `ground(Term)` -- удаётся, если Term не содержит свободных переменных 

## Задание 1: Определение предиката `factorial(N, FactN)`

Определите предикат `factorial(N, FactN)`, который выполняется, если `FactN` -- факториал `N`.

Пример:
```prolog
?- fact(3, X).
X = 6
```

## Задание 2: Определение предиката `occurrences(Elem, List, Number)`

Определите предикат `occurrences(Elem, List, Number)`, который выполняется, если элемент `Elem` встречается в списке `List` `Number` раз.

Пример:
```prolog
?- occurrences(3, [1,2,3,1,3], N).
N = 2
```

## Задание 3: Определение предиката `rule(Rule)`

Определите предикат `rule(Rule)`, который проверяет, является ли терм `Rule` правилом (без точки в конце), то есть: 1. Голова правила может быть вызвана (в смысле `callable/1`); 2. Тело правила состоит из (1 или более) callable термов, разделённых ',' и ';' (заметьте, что `T1,T2` и `T1;T2` -- сами callable, но их нужно обрабатывать отдельно).

Примеры:
```prolog
?- rule(p(X, Y) :- q(X)).
Yes
?- rule(p :- q(X), r, r).
Yes
?- rule(4 :- p, q).
No
?- rule(p :- 4, q).
No
```

## Задание 4: Определение предиката `eval_arithmetic(Expr, Values, Result)`

Определите предикат `eval_arithmetic(Expr, Values, Result)`, который выполняется, если `Expr` -- арифметическое выражение (содержащее операторы +, *, -, / и атомы в качестве переменных), `Values` -- список термов `Var = Val`, где `Var` -- атом, а `Val` -- число, а `Result` -- результат вычисления `Expr` при подстановке вместо каждого атома соответствующего ему значения из `Values`. 

Пример:
```prolog
?- eval_arithmetic(x + 3*y, [x = 2, y = 1], Result).
Result = 5
```

## Задание 5: Определение предиката `prime_factors(Num, Factors)`

Определите предикат `prime_factors(Num, Factors)`, находящий все простые делители числа `Num` и их кратность.

Пример:
```prolog
?- prime_factors(315, L).
L = [factor(3,2),factor(5,1),factor(7,1)] %% означает, что 315 = 3^2 * 5^1 * 7^1
```

## Задание 6: Определение предиката `polynomize(Expr, Poly)`

Определите предикат `polynomize(Expr, Poly)`, который выполняется, если `Expr` -- арифметическое выражение (включающее операции +, *, ^ в константную степень), а `Poly` -- многочлен в нормальной форме (см. 1.3), получающийся в результате его упрощения.

Пример:
```prolog
?- polynomize((x + x)*(x + 1), Poly).
Poly = 2*x^2 + 2*x
```

