# LAB 2

## 1. Функция `min_positive_number(List)`

Реализуйте функцию `min_positive_number(List)`, которая возвращает минимальное положительное число, входящее в `List`. Если положительных чисел нет, функция должна вернуть атом `error`.


```prolog
min_positive_number([3,a,false,-3,1]) => 1
```

## 2. Функция `zipwith(Fun, List1, List2)`

Не смотря на определение в модуле `lists` стандартной библиотеки, реализуйте функцию `zipwith(Fun, List1, List2)`. Возвращается список значений `Fun` (функции от двух аргументов) на аргументах, взятых из списков `List1` и `List2`. В случае разных длин списков функция должна выкинуть исключение.

**Пример:**
```
zipwith(fun(X, Y) -> {X, Y} end, [1,2,3], [4,5,6]) => [{1,4}, {2,5}, {3,6}]
```

## 3. Функция `iteratemap(F, X0, N)`

Реализуйте функцию `iteratemap(F, X0, N)`, которая возвращает список длины `N`, состоящий из результатов последовательного применения `F` к `X0`.

**Пример:**
```
iteratemap(fun(X) -> X*2 end, 1, 4) => [1, 2, 4, 8]
```

## 4. Функция `diff(F, DX)`

Реализуйте функцию `diff(F, DX)`, которая принимает функцию `F` от одного аргумента и шаг `DX`, и возвращает функцию одного аргумента: приближение к производной функции `F`. 

**Пример:**
```
F1 = diff(fun(X) -> X*X end, 0.001), F1(1.0) => 2.000 (приближенно)
```

Попробуйте вспомнить (или найти) формулу, которая даёт лучшее приближение для производной, чем `(F(X + DX) - F(X))/DX`, но она тоже принимается.

## 5. Функция `for(Init, Cond, Step, Body)`

Реализуйте функцию `for(Init, Cond, Step, Body)`, которая работает как цикл `for` (I = Init; Cond(I); I = Step(I)) { Body(I) } в C-подобных языках:

- Поддерживается "текущее значение" `I`. В начале это `Init`.
- На каждом шаге проверяется, выполняется ли условие `Cond(I)`.
- Если да, то вызывается функция `Body(I)`. Потом вычисляется новое значение как `Step(I)` и возвращаемся к проверке `Cond`.
- Если нет, то работа функции заканчивается.

## 6. Функция `sortBy(Comparator, List)`

Реализуйте функцию `sortBy(Comparator, List)`, которая сортирует список `List`, используя `Comparator` для сравнения элементов. `Comparator(X, Y)` возвращает один из атомов `less` (если `X < Y`), `equal` (`X == Y`), `greater` (`X > Y`) для любых элементов `List`. Можете использовать любой алгоритм сортировки, но укажите, какой именно. Сортировка слиянием очень хорошо подходит для связных списков.
