

# Лабораторная работа 8

## Задание 1: Определение предиката `not_member(X, List)`

### Описание задачи
Определить предикат `not_member(X, List)`, который истинен, если элемент `X` не содержится в списке `List`. Не использовать `\+`, а использовать предикат `member` и комбинацию `!` и `fail`.


Если X присутствует в List, то мы вызываем member(X, List), затем отсечение ! предотвращает дальнейшие откаты, и fail заставляет предикат завершиться неудачей.
Если X не найден, то member(X, List) никогда не срабатывает, и выполняется последний факт not_member(_, _)., что приводит к успешному завершению.


Запрос 1:
```prolog
not_member(2, [1,2,3,4]).
```

Разбор:
Вызывается member(2, [1,2,3,4]) → успешно (2 есть в списке).
Затем выполняется ! (отсечение), что предотвращает любые альтернативные пути.
fail завершает предикат с неудачей.
Ответ: No (2 есть в списке, значит, предикат not_member ложен).


Запрос 2:
```prolog
?- not_member(5, [1,2,3,4]).
```
Разбор:
member(5, [1,2,3,4]) → не удается (5 нет в списке).
Следовательно, Prolog перемещается к следующему факту not_member(_, _)..
Этот факт всегда успешен.
Ответ: Yes (5 отсутствует в списке, значит, предикат not_member истинен).


### Примеры работы
```prolog
not_member(2, [1,2,3,4]).

not_member(5, [1,2,3,4]).
```

<img width="582" alt="image" src="https://github.com/user-attachments/assets/63455e34-4086-4be1-ab55-5f9d32473cd8" />


### Реализация
#### Предикат `not_member/2`
```prolog
 not_member(X, List) проверяет, что X не содержится в List
% Реализация использует member/2, отсечение (!) и fail для предотвращения откатов
not_member(X, List) :-
    member(X, List), % Проверяем, содержится ли X в List
    !, % Отсекаем дальнейшие попытки после первого совпадения
    fail. % Если X найден, то предикат завершается с неудачей
not_member(_, _). % Если X не найден, предикат успешно завершается

```

## Задание 2: Определение предиката `delete_first(List, X, Result)`

### Описание задачи
Определить предикат `delete_first(List, X, Result)`, который удаляет из списка `List` первое вхождение элемента `X`.

### Примеры работы
```prolog
?- delete_first([1,2,3,4,3,5], 3, X).
X = [1, 2, 4, 3, 5]
```

### Реализация
#### Предикат `delete_first/3`
```prolog
% Реализация предиката delete_first/3

```

## Задание 3: Определение предиката `set_diff(List1, List2, Result)`

### Описание задачи
Определить предикат `set_diff(List1, List2, Result)`, который находит все элементы списка `List1`, которые не входят в список `List2`.

### Примеры работы
```prolog
?- set_diff([1,2,3,4,3,5], [2,3,6], X).
X = [1, 4, 5]
```

### Реализация
#### Предикат `set_diff/3`
```prolog
% Реализация предиката set_diff/3

```

## Задание 4: Улучшение эффективности с использованием зелёных сечений

### Описание задачи
Вернуться к решениям лабораторных работ 6 и 7. Найти места, где можно расставить зелёные сечения для улучшения эффективности. Исправить случаи, когда Prolog выдаёт неправильные дополнительные решения после отката.

### Анализ и исправление
#### Лабораторная работа 6
- **Задача 3**
    - Анализ текущей реализации
    - Расстановка зелёных сечений
    - Проверка корректности решений
- **Задача 4**
    - Анализ текущей реализации
    - Расстановка зелёных сечений
    - Проверка корректности решений

#### Лабораторная работа 7
- Аналогичный анализ и исправление для задач лабораторной работы 7

## Задание 5: Определение предиката `unifiable(List, Term, Result)`

### Описание задачи
Определить предикат `unifiable(List, Term, Result)`, который возвращает список всех элементов `List`, которые можно сопоставить с `Term`, но без конкретизации входящих переменных.

### Примеры работы
```prolog
?- unifiable([X, b, t(Y)], t(a), List].
List = [X, t(Y)] %% X = t(a) и t(Y) = t(a) удаются, b = t(a) -- нет
```

### Реализация
#### Предикат `unifiable/3`
```prolog
% Реализация предиката unifiable/3

```

