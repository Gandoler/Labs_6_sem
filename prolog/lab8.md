

# Лабораторная работа 8

## Задание 1: Определение предиката `not_member(X, List)`

### Описание задачи
Определить предикат `not_member(X, List)`, который истинен, если элемент `X` не содержится в списке `List`. Не использовать `\+`, а использовать предикат `member` и комбинацию `!` и `fail`.


Если X присутствует в List, то мы вызываем member(X, List), затем отсечение ! предотвращает дальнейшие откаты, и fail заставляет предикат завершиться неудачей.
Если X не найден, то member(X, List) никогда не срабатывает, и выполняется последний факт not_member(_, _)., что приводит к успешному завершению.


Запрос 1:
```prolog
not_member(2, [1,2,3,4]).
```

Разбор:
Вызывается member(2, [1,2,3,4]) → успешно (2 есть в списке).
Затем выполняется ! (отсечение), что предотвращает любые альтернативные пути.
fail завершает предикат с неудачей.
Ответ: No (2 есть в списке, значит, предикат not_member ложен).


Запрос 2:
```prolog
?- not_member(5, [1,2,3,4]).
```
Разбор:
member(5, [1,2,3,4]) → не удается (5 нет в списке).
Следовательно, Prolog перемещается к следующему факту not_member(_, _)..
Этот факт всегда успешен.
Ответ: Yes (5 отсутствует в списке, значит, предикат not_member истинен).


### Примеры работы
```prolog
not_member(2, [1,2,3,4]).

not_member(5, [1,2,3,4]).
```

<img width="582" alt="image" src="https://github.com/user-attachments/assets/63455e34-4086-4be1-ab55-5f9d32473cd8" />


### Реализация
#### Предикат `not_member/2`
```prolog
 not_member(X, List) проверяет, что X не содержится в List
% Реализация использует member/2, отсечение (!) и fail для предотвращения откатов
not_member(X, List) :-
    member(X, List), % Проверяем, содержится ли X в List
    !, % Отсекаем дальнейшие попытки после первого совпадения
    fail. % Если X найден, то предикат завершается с неудачей
not_member(_, _). % Если X не найден, предикат успешно завершается

```

## Задание 2: Определение предиката `delete_first(List, X, Result)`

### Описание задачи
Определить предикат `delete_first(List, X, Result)`, который удаляет из списка `List` первое вхождение элемента `X`.

Если список пуст, результат — тоже пуст (delete_first([], _, []).).
Если первый элемент списка равен X, он удаляется, а оставшаяся часть списка становится результатом (delete_first([X|T], X, T).).
Если первый элемент не равен X, он сохраняется, а функция вызывается рекурсивно для оставшихся элементов (delete_first([H|T], X, [H|Result]).).

Разбор по шагам:
[1,2,3,4,3,5] → первый элемент 1 не равен 3, идем дальше:

```prolog
delete_first([2,3,4,3,5], 3, Result).
```
После возврата [2, 4, 3, 5], мы восстанавливаем [1 | Result] = [1,2,4,3,5].

[2,3,4,3,5] → первый элемент 2 не равен 3, идем дальше:

```prolog
delete_first([3,4,3,5], 3, Result).
```
После возврата [4,3,5], восстанавливаем [2 | Result] = [2,4,3,5].

[3,4,3,5] → первый элемент 3 совпал! Удаляем его и не вызываем рекурсию дальше:

```prolog
delete_first([3,4,3,5], 3, [4,3,5]).
```
Здесь срабатывает правило delete_first([X|T], X, T)., сечение (!) прерывает поиск, не удаляя вторую 3.

Почему важно отсечение !?
Без него предикат мог бы искать дополнительные решения, например, удаляя все вхождения 3 при откате.
! заставляет предикат остановиться, как только первая 3 найдена и удалена.

### Примеры работы
```prolog
delete_first([1,2,3,4,3,5], 3, X).
```

<img width="717" alt="image" src="https://github.com/user-attachments/assets/e5141cae-53e2-46e5-9888-c57dd71e6c7d" />


### Реализация
#### Предикат `delete_first/3`
```prolog
% delete_first(List, X, Result) удаляет только первое вхождение X в List
% Используем рекурсию и отсечение (!) для предотвращения ненужных проверок
delete_first([], _, []). % Если список пуст, результат тоже пуст

delete_first([X|T], X, T) :-
    !. % Как только нашли X, удаляем его и останавливаемся

delete_first([H|T], X, [H|Result]) :-
    delete_first(T, X, Result). % Продолжаем рекурсию, если X не найден

```

## Задание 3: Определение предиката `set_diff(List1, List2, Result)`

### Описание задачи
Определить предикат `set_diff(List1, List2, Result)`, который находит все элементы списка `List1`, которые не входят в список `List2`.

### Примеры работы
```prolog
?- set_diff([1,2,3,4,3,5], [2,3,6], X).
X = [1, 4, 5]
```

### Реализация
#### Предикат `set_diff/3`
```prolog
% Реализация предиката set_diff/3

```

## Задание 4: Улучшение эффективности с использованием зелёных сечений

### Описание задачи
Вернуться к решениям лабораторных работ 6 и 7. Найти места, где можно расставить зелёные сечения для улучшения эффективности. Исправить случаи, когда Prolog выдаёт неправильные дополнительные решения после отката.

### Анализ и исправление
#### Лабораторная работа 6
- **Задача 3**
    - Анализ текущей реализации
    - Расстановка зелёных сечений
    - Проверка корректности решений
- **Задача 4**
    - Анализ текущей реализации
    - Расстановка зелёных сечений
    - Проверка корректности решений

#### Лабораторная работа 7
- Аналогичный анализ и исправление для задач лабораторной работы 7

## Задание 5: Определение предиката `unifiable(List, Term, Result)`

### Описание задачи
Определить предикат `unifiable(List, Term, Result)`, который возвращает список всех элементов `List`, которые можно сопоставить с `Term`, но без конкретизации входящих переменных.

### Примеры работы
```prolog
?- unifiable([X, b, t(Y)], t(a), List].
List = [X, t(Y)] %% X = t(a) и t(Y) = t(a) удаются, b = t(a) -- нет
```

### Реализация
#### Предикат `unifiable/3`
```prolog
% Реализация предиката unifiable/3

```

