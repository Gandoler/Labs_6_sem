

# Лабораторная работа 8

## Задание 1: Определение предиката `not_member(X, List)`

### Описание задачи
Определить предикат `not_member(X, List)`, который истинен, если элемент `X` не содержится в списке `List`. Не использовать `\+`, а использовать предикат `member` и комбинацию `!` и `fail`.


Если X присутствует в List, то мы вызываем member(X, List), затем отсечение ! предотвращает дальнейшие откаты, и fail заставляет предикат завершиться неудачей.
Если X не найден, то member(X, List) никогда не срабатывает, и выполняется последний факт not_member(_, _)., что приводит к успешному завершению.


Запрос 1:
```prolog
not_member(2, [1,2,3,4]).
```

Разбор:
Вызывается member(2, [1,2,3,4]) → успешно (2 есть в списке).
Затем выполняется ! (отсечение), что предотвращает любые альтернативные пути.
fail завершает предикат с неудачей.
Ответ: No (2 есть в списке, значит, предикат not_member ложен).


Запрос 2:
```prolog
?- not_member(5, [1,2,3,4]).
```
Разбор:
member(5, [1,2,3,4]) → не удается (5 нет в списке).
Следовательно, Prolog перемещается к следующему факту not_member(_, _)..
Этот факт всегда успешен.
Ответ: Yes (5 отсутствует в списке, значит, предикат not_member истинен).


### Примеры работы
```prolog
not_member(2, [1,2,3,4]).

not_member(5, [1,2,3,4]).
```

<img width="582" alt="image" src="https://github.com/user-attachments/assets/63455e34-4086-4be1-ab55-5f9d32473cd8" />


### Реализация
#### Предикат `not_member/2`
```prolog
 not_member(X, List) проверяет, что X не содержится в List
% Реализация использует member/2, отсечение (!) и fail для предотвращения откатов
not_member(X, List) :-
    member(X, List), % Проверяем, содержится ли X в List
    !, % Отсекаем дальнейшие попытки после первого совпадения
    fail. % Если X найден, то предикат завершается с неудачей
not_member(_, _). % Если X не найден, предикат успешно завершается

```

## Задание 2: Определение предиката `delete_first(List, X, Result)`

### Описание задачи
Определить предикат `delete_first(List, X, Result)`, который удаляет из списка `List` первое вхождение элемента `X`.

Если список пуст, результат — тоже пуст (delete_first([], _, []).).
Если первый элемент списка равен X, он удаляется, а оставшаяся часть списка становится результатом (delete_first([X|T], X, T).).
Если первый элемент не равен X, он сохраняется, а функция вызывается рекурсивно для оставшихся элементов (delete_first([H|T], X, [H|Result]).).

Разбор по шагам:
[1,2,3,4,3,5] → первый элемент 1 не равен 3, идем дальше:

```prolog
delete_first([2,3,4,3,5], 3, Result).
```
После возврата [2, 4, 3, 5], мы восстанавливаем [1 | Result] = [1,2,4,3,5].

[2,3,4,3,5] → первый элемент 2 не равен 3, идем дальше:

```prolog
delete_first([3,4,3,5], 3, Result).
```
После возврата [4,3,5], восстанавливаем [2 | Result] = [2,4,3,5].

[3,4,3,5] → первый элемент 3 совпал! Удаляем его и не вызываем рекурсию дальше:

```prolog
delete_first([3,4,3,5], 3, [4,3,5]).
```
Здесь срабатывает правило delete_first([X|T], X, T)., сечение (!) прерывает поиск, не удаляя вторую 3.

Почему важно отсечение !?
Без него предикат мог бы искать дополнительные решения, например, удаляя все вхождения 3 при откате.
! заставляет предикат остановиться, как только первая 3 найдена и удалена.

### Примеры работы
```prolog
delete_first([1,2,3,4,3,5], 3, X).
```

<img width="717" alt="image" src="https://github.com/user-attachments/assets/e5141cae-53e2-46e5-9888-c57dd71e6c7d" />


### Реализация
#### Предикат `delete_first/3`
```prolog
% delete_first(List, X, Result) удаляет только первое вхождение X в List
% Используем рекурсию и отсечение (!) для предотвращения ненужных проверок
delete_first([], _, []). % Если список пуст, результат тоже пуст

delete_first([X|T], X, T) :-
    !. % Как только нашли X, удаляем его и останавливаемся

delete_first([H|T], X, [H|Result]) :-
    delete_first(T, X, Result). % Продолжаем рекурсию, если X не найден

```
Сечение (!) — это специальный предикат в Prolog, который отсекает (удаляет) все альтернативные пути поиска решений после его выполнения. Оно предотвращает ненужные откаты (backtracking), улучшает эффективность программы и помогает избежать лишних решений.

## Задание 3: Определение предиката `set_diff(List1, List2, Result)`

### Описание задачи
Определить предикат `set_diff(List1, List2, Result)`, который находит все элементы списка `List1`, которые не входят в список `List2`.



### Примеры работы
```prolog
set_diff([1,2,3,4,3,5], [2,3,6], X).
```

<img width="681" alt="image" src="https://github.com/user-attachments/assets/9aea9a02-e37f-441e-b89a-4baaa96d6284" />


### Реализация
#### Предикат `set_diff/3`
```prolog
% set_diff(List1, List2, Result) оставляет только элементы List1, которых нет в List2
set_diff([], _, []). % Если List1 пуст, результат пуст

set_diff([H|T], List2, Result) :-
    member(H, List2), % Если H есть в List2, пропускаем его
    !, % Отсекаем, чтобы избежать ненужных откатов
    set_diff(T, List2, Result).

set_diff([H|T], List2, [H|Result]) :-
    set_diff(T, List2, Result). % Добавляем H в результат, если он не в List2
```

## Задание 4: Улучшение эффективности с использованием зелёных сечений

### Описание задачи
Вернуться к решениям лабораторных работ 6 и 7. Найти места, где можно расставить зелёные сечения для улучшения эффективности. Исправить случаи, когда Prolog выдаёт неправильные дополнительные решения после отката.

### Анализ и исправление
#### Лабораторная работа 6
- **Задача 3**
    - Анализ текущей реализации
    - Расстановка зелёных сечений
    - Проверка корректности решений
- **Задача 4**
    - Анализ текущей реализации
    - Расстановка зелёных сечений
    - Проверка корректности решений

#### Лабораторная работа 7
Оптимизация factorial/2
В предикате factorial/2 можно добавить сечение после базового случая. Это предотвратит ненужные попытки применения рекурсивного правила к N = 0.

```prolog
factorial(0, 1) :- !.  % Сечение предотвращает дальнейшие попытки унификации.
factorial(N, FactN) :-
    N > 0,
    N1 is N - 1,
    factorial(N1, FactN1),
    FactN is N * FactN1.
```
 Улучшение: Исключает бесполезный откат после базового случая.

Оптимизация occurrences/3
Добавим сечение после первого правила, чтобы избежать ненужных откатов при пустом списке.

```prolog

occurrences(_, [], 0) :- !.  % Если список пуст, дальнейшие проверки не нужны.
occurrences(Elem, [Elem|Tail], N) :-
    occurrences(Elem, Tail, N1),
    N is N1 + 1, !.  % Сечение предотвращает ненужный откат.
occurrences(Elem, [_|Tail], N) :- 
    occurrences(Elem, Tail, N).
```
Улучшение: Исключает лишние проверки после подсчёта элемента.

Оптимизация rule/1
В rule/1 можно использовать сечение, чтобы сразу вернуть false, если Head не является вызываемым термом.

```prolog

rule(Head :- Body) :-
    callable(Head), !,   % Если Head нельзя вызвать, дальше проверять бессмысленно.
    valid_body(Body).

valid_body(true) :- !.
valid_body(Term) :- callable(Term), !.
valid_body((T1, T2)) :- valid_body(T1), valid_body(T2).
valid_body((T1; T2)) :- valid_body(T1), valid_body(T2).
```
Улучшение: Останавливает проверку при некорректной голове правила.

## Задание 5: Определение предиката `unifiable(List, Term, Result)`

### Описание задачи
Определить предикат `unifiable(List, Term, Result)`, который возвращает список всех элементов `List`, которые можно сопоставить с `Term`, но без конкретизации входящих переменных.

Унификация — это процесс сопоставления двух термов и поиска подстановки, при которой они становятся равными.

Примеры унификации:

X = a → X становится a
t(Y) = t(a) → Y становится a
f(A, B) = f(1, 2) → A = 1, B = 2
b = t(a) → ложь, так как b и t(a) — разные константы

Предикат проходит по списку и проверяет, унифицируется ли каждый элемент с Term:

Если да → добавляет элемент в результат.
Если нет → пропускает его.

```prolog
unifiable([H|T], Term, [H|Result]) :-
    \+ \+ (H = Term), % Двойное отрицание предотвращает конкретизацию переменных
    !, % Отсекаем откаты, чтобы избежать лишних попыток
    unifiable(T, Term, Result).
```

Берёт первый элемент H списка.
Проверяет, можно ли его унифицировать с Term (H = Term).
Двойное отрицание \+ \+ нужно, чтобы не изменять H (не присваивать ему значение).
Если унификация возможна, H добавляется в Result.
! отсекает дальнейшие попытки.

### Примеры работы
```prolog
unifiable([X, b, t(Y)], t(a), List).
```
<img width="664" alt="image" src="https://github.com/user-attachments/assets/4902729b-6d98-494b-a90e-38e727177b87" />

### Реализация
#### Предикат `unifiable/3`
```prolog
% unifiable(List, Term, Result) находит все элементы List, которые можно унифицировать с Term
unifiable([], _, []). % Если List пуст, результат пуст

unifiable([H|T], Term, [H|Result]) :-
    \+ \+ (H = Term), % Проверяем унификацию без конкретизации переменных
    !, % Отсекаем откаты, чтобы избежать лишних попыток
    unifiable(T, Term, Result).

unifiable([_|T], Term, Result) :-
    unifiable(T, Term, Result). % Пропускаем элемент, если он не унифицируется


```

