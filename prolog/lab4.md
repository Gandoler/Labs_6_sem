Конечно, вот пример разметки для отчета в формате Markdown:

```markdown
# Лабораторная работа по параллельному программированию

## Задание 1: Реализация процесса-"счётчика"

### Описание задачи
Реализовать процесс-"счётчик", который запускается со значением 0 и:
- Если получает атом `stop`, выводит текущее значение и завершает работу.
- Если получает любое другое сообщение, увеличивает значение на 1 и выводит сообщение об этом.

Модуль должен предоставлять следующий интерфейс:
- `counter:start() => ok`
- `counter:incr() => ok`
- `counter:stop() => ok`

### Пример работы
```erlang
> counter:start().
Started <0.33.0>
ok
> counter:incr().
Incremented counter value (now 1)
ok
> counter:incr().
Incremented counter value (now 2)
ok
> counter:stop().
Stopped!
ok
```

### Реализация
#### Модуль `counter.erl`
```erlang
-module(counter).
-export([start/0, incr/0, stop/0]).

% Реализация функций start/0, incr/0, stop/0

```

## Задание 2: Реализация модуля `parent_children`

### Описание задачи
Реализовать модуль `parent_children`:
- `start(N::integer())` запускает N+1 процесс: "родитель" и N "детей". Каждый из детей ждёт сообщений. Если получено сообщение `stop`, процесс останавливается без ошибки; если получено сообщение `die`, процесс падает с ошибкой; любое другое сообщение печатается в оболочке. В случае, если один из детей умрёт с ошибкой, родитель его перезапускает и печатает сообщение об этом. Если родитель умирает, все дети тоже должны умереть.
- `send_to_child(I::integer(), Msg::any())` посылает родителю сообщение, после которого он пересылает `Msg` ребёнку номер `I`.
- `stop()` останавливает родителя.

### Реализация
#### Модуль `parent_children.erl`
```erlang
-module(parent_children).
-export([start/1, send_to_child/2, stop/0]).

% Реализация функций start/1, send_to_child/2, stop/0

```

## Задание 3: Реализация функции `par_map(F, List)`

### Описание задачи
Реализовать функцию `par_map(F, List)`, которая возвращает список с теми же элементами, что `lists:map(F, List)` (но не обязательно в том же порядке).

### Реализация
#### Функция `par_map/2`
```erlang
% Реализация функции par_map/2

```

## Задание 4-5: Оформление решений как OTP-приложение

### Описание задачи
Познакомиться с OTP и оформить решения задач 1 и 2 как OTP-приложение.

### Реализация
#### Приложение OTP
```erlang
% Реализация приложения OTP

```

## Задание 6: Расширение функциональности

### Описание задачи
То же, что задание 3, но элементы должны возвращаться в том же порядке (кроме варианта 3). Для варианта 3 реализовать функцию `par_sort(List, Options)`, которая сортирует список параллельно с помощью сортировки.

### Реализация
#### Функция `par_map/2` с сохранением порядка
```erlang
% Реализация функции par_map/2 с сохранением порядка

```

#### Функция `par_sort/2`
```erlang
% Реализация функции par_sort/2

```

## Выводы
В данном отчете были рассмотрены и реализованы различные задачи по параллельному программированию на языке Erlang. Были созданы процессы-"счётчики", модуль управления родительскими и дочерними процессами, функция параллельного применения функции к списку, а также было познакомлено с OTP и оформлены решения как OTP-приложение.
