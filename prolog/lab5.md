<img width="559" alt="image" src="https://github.com/user-attachments/assets/dc7730e8-5a54-4dd7-91aa-81d53b7ba1c7" /># Задание 1: Классификация термов

| Последовательность | Классификация |
|---------------------|----------------|
| переменная          | атом     |
| 'язык Пролог'       | Атом           |
| Пролог              | Переменная           |
| Альберт(любит, мясо)| ❌ Некорректный терм  |
| любит(Альберт, мясо)| Сложный терм   |

### Объяснение:
- **Переменная**: В Prolog переменные начинаются с заглавной буквы или с _ (подчёркивания). Слово переменная написано с маленькой буквы, а значит, это атом.
- **'язык Пролог'**: Это строка, заключенная в апострофы, что делает её атомом.
- **Пролог**: Пролог написан с заглавной буквы, а в Prolog всё, что начинается с большой буквы, считается переменной.
- **Альберт(любит, мясо)**: Здесь Альберт написан с заглавной буквы, а значит, это переменная, а не предикат.
Prolog не воспринимает переменную (Альберт) с аргументами как корректный терм.
Правильная классификация: ❌ не является корректным термом в Prolog..
- **любит(Альберт, мясо)**: Это также сложный терм, так как он состоит из имени предиката (любит) и аргументов (Альберт, мясо).

# Задание 2: Сопоставление термов

1. meal(food(Y), X) = meal(X, drink(Z)) — Успешно, если X = food(Y) и drink(Z) = food(Y). Это невозможно, так как food(Y) и drink(Z) не могут быть равны.

<img width="759" alt="image" src="https://github.com/user-attachments/assets/063f57f1-fbe3-4f95-80e2-92e7d7e9916d" />

2. `food(bread, X, beer) = food(Y, burger)`
   - Не удастся, так как структуры не совпадают.
   - Левый терм: food(bread, X, beer) (3 аргумента).
   - Правый терм: food(Y, burger) (2 аргумента).

<img width="756" alt="image" src="https://github.com/user-attachments/assets/e2e9501c-d074-4b42-bdbc-fe86fd4fa1c2" />


3. `likes(X, cola) = likes(Y, cola)`
   - Удастся с `X = Y`.

<img width="752" alt="image" src="https://github.com/user-attachments/assets/8fd26916-2bcf-425c-af20-491ffd070faa" />


4. `'bread' = bread`
   -  удастся
   -  Левый терм: 'bread' (атом в кавычках).
   -  Правый терм: bread (атом без кавычек).
   -  В Prolog атомы 'bread' и bread эквивалентны, если bread не является переменной.

 <img width="753" alt="image" src="https://github.com/user-attachments/assets/f1b133a0-2177-4bd4-a9e6-410dd9c0c0be" />


5. `likes(X, food(Y)) = likes(Y, food(Z))`
   - Удастся с `X = Y` и `Y = Z`.
  
<img width="751" alt="image" src="https://github.com/user-attachments/assets/844f5ce5-4c39-4c21-9bf0-84b2a4b02162" />



# Задание 3: Формулировка запросов на языке Prolog

пример

```prolog
% Факты о том, кто является отцом
отец(иван, сергей).
отец(иван, мария).
отец(сергей, алексей).
```


1. **Кто отец Сергея?**
   
```prolog
отец(Отец, сергей).
```
   
<img width="559" alt="image" src="https://github.com/user-attachments/assets/a3ae9954-db42-4b6d-95d2-3e1ef501e0c9" />

пример

```prolog
родитель_ребёнок(иван, сергей).
родитель_ребёнок(иван, мария).
родитель_ребёнок(анна, сергей).
родитель_ребёнок(анна, мария).
родитель_ребёнок(сергей, алексей).
родитель_ребёнок(мария, ольга).
```

2. **Есть ли дети у Ивана?**

```prolog
родитель_ребёнок(иван, Ребёнок).
```
   
<img width="717" alt="image" src="https://github.com/user-attachments/assets/d9d1501a-31dd-4633-a3b6-69da8853f8a3" />

### Объяснение:
Запросы в Prolog формулируются с использованием предикатов и переменных. В первом случае мы спрашиваем, кто (`X`) является отцом Сергея. Во втором случае проверяем, есть ли у Ивана (`иван`) дети.

# Задание 4: Формулировка правила на языке Prolog

```prolog
% Факты о браке
женат(иван).
жена(иван, мария).

% Факты о родителях и детях
родитель_ребёнок(иван, сергей).
родитель_ребёнок(иван, ольга).
родитель_ребёнок(мария, сергей).
родитель_ребёнок(мария, ольга).

% Правило
дети_жены(X, Y) :-
    женат(X),
    родитель_ребёнок(X, Y),
    жена(X, Z),
    родитель_ребёнок(Z, Y).


```
<img width="912" alt="image" src="https://github.com/user-attachments/assets/5f6c16dd-3057-4b59-8f93-ad5315221929" />

### Объяснение:
-Prolog проверяет, что иван женат (женат(иван) — истина).
-Prolog находит детей Ивана: сергей и ольга (родитель_ребёнок(иван, сергей) и родитель_ребёнок(иван, ольга)).
-Prolog находит жену Ивана: мария (жена(иван, мария)).
-=Prolog проверяет, что сергей и ольга также являются детьми марии (родитель_ребёнок(мария, сергей) и родитель_ребёнок(мария, ольга)).

# Задание 5: Определение предиката двоюродные_братья/2

```prolog
% Факты о родителях и детях
родитель_ребёнок(назим, сергей).
родитель_ребёнок(назим, олег).
родитель_ребёнок(денчик, никита).
родитель_ребёнок(денчик, милена).

% Факты о братьях
братья(назим, денчик).
братья(денчик, назим).

% Предикат для поиска двоюродных братьев
двоюродные_братья(X, Y) :-
    родитель_ребёнок(РодительX, X), % РодительX — родитель X
    родитель_ребёнок(РодительY, Y), % РодительY — родитель Y
    братья(РодительX, РодительY).   % РодительX и РодительY — братья
```

<img width="1087" alt="image" src="https://github.com/user-attachments/assets/05c430b9-8d85-403a-8b5d-010b7ada241d" />


### Объяснение:
Двоюродные братья (`X`, `Y`) имеют общих родителей (`РодительX`, `РодительY`), которые сами являются братьями, и `X` не равно `Y`.

# Задание 6: Создание базы данных

### Тема: Книги

#### Предикаты фактами
```prolog
автор(харпер_ли, "Убить пересмешника").
жанр("Убить пересмешника", драма).
год_выхода("Убить пересмешника", 1960).

автор(джордж_орвелл, "1984").
жанр("1984", антиутопия).
год_выхода("1984", 1949).
```

#### Предикаты правилами
```prolog
известный_автор(Автор) :-
    автор(Автор, _),
    findall(Год, год_выхода(_, Год), Годы),
    length(Годы, N),
    N > 2.

все_книги_автора(Автор, Книги) :-
    findall(Книга, автор(Автор, Книга), Книги).
```

### Объяснение:
- **известный_автор/1**: Автор считается известным, если у него более двух книг.
- **все_книги_автора/2**: Возвращает все книги данного автора.

# Задание 7: Определение предиката связаны/2

```prolog
связаны(X, Y) :-
    есть_рейс(X, Y).

связаны(X, Y) :-
    есть_рейс(X, Z),
    связаны(Z, Y).
```

### Объяснение:
Предикат `связаны/2` определяет, можно ли попасть из города `X` в город `Y` за один или несколько рейсов. Первое правило проверяет прямой рейс, второе — рекурсивно проверяет наличие промежуточных рейсов.

# Задание 7': Использование рейсов в обоих направлениях

```prolog
связаны(X, Y) :-
    есть_рейс(X, Y);
    есть_рейс(Y, X).

связаны(X, Y) :-
    есть_рейс(X, Z),
    связаны(Z, Y).

связаны(X, Y) :-
    есть_рейс(Y, Z),
    связаны(X, Z).
```

### Объяснение:
Добавлены дополнительные правила для учета рейсов в обоих направлениях.

# Задание 7'': Поддержка циклов

```prolog
связаны(X, Y, Посещенные) :-
    есть_рейс(X, Y),
    not(member(Y, Посещенные)).

связаны(X, Y, Посещенные) :-
    есть_рейс(X, Z),
    not(member(Z, Посещенные)),
    связаны(Z, Y, [Z|Посещенные]).
```

### Объяснение:
Добавлен параметр `Посещенные` для отслеживания посещенных городов и предотвращения зацикливания.
