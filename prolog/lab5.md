<img width="559" alt="image" src="https://github.com/user-attachments/assets/dc7730e8-5a54-4dd7-91aa-81d53b7ba1c7" /># Задание 1: Классификация термов

| Последовательность | Классификация |
|---------------------|----------------|
| переменная          | Переменная     |
| 'язык Пролог'       | Атом           |
| Пролог              | атом           |
| Альберт(любит, мясо)| ❌ Некорректный терм  |
| любит(Альберт, мясо)| Сложный терм   |

### Объяснение:
- **Переменная**: В Prolog переменные начинаются с заглавной буквы или с _ (подчёркивания). Слово переменная написано с маленькой буквы, а значит, это атом.
- **'язык Пролог'**: Это строка, заключенная в апострофы, что делает её атомом.
- **Пролог**: Пролог написан с заглавной буквы, а в Prolog всё, что начинается с большой буквы, считается переменной.
- **Альберт(любит, мясо)**: Здесь Альберт написан с заглавной буквы, а значит, это переменная, а не предикат.
Prolog не воспринимает переменную (Альберт) с аргументами как корректный терм.
Правильная классификация: ❌ не является корректным термом в Prolog..
- **любит(Альберт, мясо)**: Это также сложный терм, так как он состоит из имени предиката (любит) и аргументов (Альберт, мясо).

# Задание 2: Сопоставление термов

1. meal(food(Y), X) = meal(X, drink(Z)) — Успешно, если X = food(Y) и drink(Z) = food(Y). Это невозможно, так как food(Y) и drink(Z) не могут быть равны.

<img width="759" alt="image" src="https://github.com/user-attachments/assets/063f57f1-fbe3-4f95-80e2-92e7d7e9916d" />

2. `food(bread, X, beer) = food(Y, burger)`
   - Не удастся, так как структуры не совпадают.
   - Левый терм: food(bread, X, beer) (3 аргумента).
   - Правый терм: food(Y, burger) (2 аргумента).

<img width="756" alt="image" src="https://github.com/user-attachments/assets/e2e9501c-d074-4b42-bdbc-fe86fd4fa1c2" />


3. `likes(X, cola) = likes(Y, cola)`
   - Удастся с `X = Y`.

<img width="752" alt="image" src="https://github.com/user-attachments/assets/8fd26916-2bcf-425c-af20-491ffd070faa" />


4. `'bread' = bread`
   -  удастся
   -  Левый терм: 'bread' (атом в кавычках).
   -  Правый терм: bread (атом без кавычек).
   -  В Prolog атомы 'bread' и bread эквивалентны, если bread не является переменной.

 <img width="753" alt="image" src="https://github.com/user-attachments/assets/f1b133a0-2177-4bd4-a9e6-410dd9c0c0be" />


5. `likes(X, food(Y)) = likes(Y, food(Z))`
   - Удастся с `X = Y` и `Y = Z`.
  
<img width="751" alt="image" src="https://github.com/user-attachments/assets/844f5ce5-4c39-4c21-9bf0-84b2a4b02162" />



# Задание 3: Формулировка запросов на языке Prolog

пример

```prolog
% Факты о том, кто является отцом
отец(иван, сергей).
отец(иван, мария).
отец(сергей, алексей).
```


1. **Кто отец Сергея?**
   
```prolog
отец(Отец, сергей).
```
   
<img width="559" alt="image" src="https://github.com/user-attachments/assets/a3ae9954-db42-4b6d-95d2-3e1ef501e0c9" />

пример

```prolog
родитель_ребёнок(иван, сергей).
родитель_ребёнок(иван, мария).
родитель_ребёнок(анна, сергей).
родитель_ребёнок(анна, мария).
родитель_ребёнок(сергей, алексей).
родитель_ребёнок(мария, ольга).
```

2. **Есть ли дети у Ивана?**

```prolog
родитель_ребёнок(иван, Ребёнок).
```
   
<img width="717" alt="image" src="https://github.com/user-attachments/assets/d9d1501a-31dd-4633-a3b6-69da8853f8a3" />

### Объяснение:
Запросы в Prolog формулируются с использованием предикатов и переменных. В первом случае мы спрашиваем, кто (`X`) является отцом Сергея. Во втором случае проверяем, есть ли у Ивана (`иван`) дети.

# Задание 4: Формулировка правила на языке Prolog

```prolog
% Факты о браке
женат(иван).
жена(иван, мария).

% Факты о родителях и детях
родитель_ребёнок(иван, сергей).
родитель_ребёнок(иван, ольга).
родитель_ребёнок(мария, сергей).
родитель_ребёнок(мария, ольга).

% Правило
дети_жены(X, Y) :-
    женат(X),
    родитель_ребёнок(X, Y),
    жена(X, Z),
    родитель_ребёнок(Z, Y).


```
<img width="912" alt="image" src="https://github.com/user-attachments/assets/5f6c16dd-3057-4b59-8f93-ad5315221929" />

### Объяснение:
-Prolog проверяет, что иван женат (женат(иван) — истина).
-Prolog находит детей Ивана: сергей и ольга (родитель_ребёнок(иван, сергей) и родитель_ребёнок(иван, ольга)).
-Prolog находит жену Ивана: мария (жена(иван, мария)).
-=Prolog проверяет, что сергей и ольга также являются детьми марии (родитель_ребёнок(мария, сергей) и родитель_ребёнок(мария, ольга)).

# Задание 5: Определение предиката двоюродные_братья/2

```prolog
% Факты о родителях и детях
родитель_ребёнок(назим, сергей).
родитель_ребёнок(назим, олег).
родитель_ребёнок(денчик, никита).
родитель_ребёнок(денчик, милена).

% Факты о братьях
братья(назим, денчик).
братья(денчик, назим).

% Предикат для поиска двоюродных братьев
двоюродные_братья(X, Y) :-
    родитель_ребёнок(РодительX, X), % РодительX — родитель X
    родитель_ребёнок(РодительY, Y), % РодительY — родитель Y
    братья(РодительX, РодительY).   % РодительX и РодительY — братья
```

<img width="1087" alt="image" src="https://github.com/user-attachments/assets/05c430b9-8d85-403a-8b5d-010b7ada241d" />


### Объяснение:
Двоюродные братья (`X`, `Y`) имеют общих родителей (`РодительX`, `РодительY`), которые сами являются братьями, и `X` не равно `Y`.

# Задание 6: Создание базы данных

### Тема: Книги


```prolog
% Факты
фильм('Начало').
фильм('Интерстеллар').
фильм('Матрица').
фильм('Женек в лабиринте').

режиссер('Начало', 'Кристофер Нолан').
режиссер('Интерстеллар', 'Кристофер Нолан').
режиссер('Матрица', 'Вачовски').
режиссер('Женек в лабиринте', 'Максопед Мартемьяныч').

актер('Начало', 'Леонардо ДиКаприо').
актер('Интерстеллар', 'Мэттью Макконахи').
актер('Матрица', 'Киану Ривз').
актер('Женек в лабиринте', 'дони Трумп').
актер('Женек в лабиринте', 'Женек').
актер('Женек в лабиринте', 'Женек-Злобный брат близнец').

% ====== ПРАВИЛА ======

% режиссер_фильма(Режиссер, Фильм)
% Позволяет узнать, какой режиссёр снял определённый фильм.
% Обращение: режиссер_фильма(Режиссер, 'Матрица').
режиссер_фильма(Режиссер, Фильм) :-
    режиссер(Фильм, Режиссер).

% актеры_фильма(Фильм, Актеры)
% Находит всех актёров, снимавшихся в данном фильме, и возвращает список.
% Обращение: актеры_фильма('Женек в лабиринте', Актеры).
актеры_фильма(Фильм, Актеры) :-
    findall(Актер, актер(Фильм, Актер), Актеры).

% режиссер_актера(Режиссер, Актер)
% Позволяет узнать, кто был режиссёром фильма, в котором снимался определённый актёр.
% Обращение: режиссер_актера(Режиссер, 'Киану Ривз').
режиссер_актера(Режиссер, Актер) :-
    актер(Фильм, Актер),  % Находим фильм, в котором играл актёр
    режиссер(Фильм, Режиссер).  % Определяем режиссёра этого фильма
```



<img width="1194" alt="image" src="https://github.com/user-attachments/assets/3cdbb2e4-5240-4fb3-86d3-b3cba1b9a0a2" />

# Задание 7: Определение предиката связаны/2

```prolog
% Факты о рейсах
есть_рейс(мос, спб).
есть_рейс(мос, ект).
есть_рейс(мос, новосиб).
есть_рейс(мос, сочи). % Добавленный промежуточный рейс

есть_рейс(спб, новосиб).
есть_рейс(спб, сочи).
есть_рейс(спб, минск).
есть_рейс(ект, сочи).
есть_рейс(сочи, киев).
есть_рейс(минск, новосиб).
есть_рейс(минск, киев).

% Базовый случай: если есть прямой рейс, то города связаны
связаны(X, Y) :- есть_рейс(X, Y).
связаны(X, Y) :- есть_рейс(Y, X). % Для учета рейсов в обе стороны

% Рекурсивный случай: города связаны через промежуточный город
связаны(X, Y) :- связаны(X, Y, [X]). % Передаём список посещённых городов

% Вспомогательный предикат с учётом посещённых городов
связаны(X, Y, Visited) :-
    (есть_рейс(X, Z) ; есть_рейс(Z, X)), % Поиск рейса в обоих направлениях
    \+ member(Z, Visited), % Проверяем, что Z ещё не посещён
    (Z = Y ; связаны(Z, Y, [Z | Visited])). % Если Z - конечный пункт, завершаем поиск

```

<img width="1009" alt="image" src="https://github.com/user-attachments/assets/ff8db3dd-88a2-4a67-a058-9c9dd82adc8b" />

### добавляем промежуточный пункт

<img width="1144" alt="image" src="https://github.com/user-attachments/assets/c9d0e1aa-1e1f-49ff-952f-0ae19642ccf0" />

### проверка в обратнуб сторону 

<img width="1062" alt="image" src="https://github.com/user-attachments/assets/c8213775-72ea-43be-b2c4-51643b1b3437" />

