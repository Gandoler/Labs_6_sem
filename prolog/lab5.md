# Задание 1: Классификация термов

| Последовательность | Классификация |
|---------------------|----------------|
| переменная          | Переменная     |
| 'язык Пролог'       | Атом           |
| Пролог              | Атом           |
| Альберт(любит, мясо)| Сложный терм   |
| любит(Альберт, мясо)| Сложный терм   |

### Объяснение:
- **Переменная**: Это просто слово "переменная", которое в Prolog является переменной.
- **'язык Пролог'**: Это строка, заключенная в апострофы, что делает её атомом.
- **Пролог**: Это слово без кавычек и скобок, что делает его атомом.
- **Альберт(любит, мясо)**: Это сложный терм, так как он состоит из имени (Альберт) и аргументов (любит, мясо).
- **любит(Альберт, мясо)**: Это также сложный терм, так как он состоит из имени предиката (любит) и аргументов (Альберт, мясо).

# Задание 2: Сопоставление термов

1. `meal(food(Y), X) = meal(X, drink(Z))`
   - Удастся с `X = food(Y)` и `Y = Z`.

2. `food(bread, X, beer) = food(Y, burger)`
   - Не удастся, так как структуры не совпадают.

3. `likes(X, cola) = likes(Y, cola)`
   - Удастся с `X = Y`.

4. `'bread' = bread`
   - Не удастся, так как `'bread'` это атом, а `bread` это переменная.

5. `likes(X, food(Y)) = likes(Y, food(Z))`
   - Удастся с `X = Y` и `Y = Z`.

### Объяснение:
Сопоставление термов в Prolog происходит путем сравнения структур и значений. Если структуры совпадают и значения могут быть присвоены переменным, то сопоставление успешно.

# Задание 3: Формулировка запросов на языке Prolog

1. **Кто отец Сергея?**
   ```prolog
   ?- отец(X, сергей).
   ```

2. **Есть ли дети у Ивана?**
   ```prolog
   ?- родитель_ребёнок(иван, _).
   ```

### Объяснение:
Запросы в Prolog формулируются с использованием предикатов и переменных. В первом случае мы спрашиваем, кто (`X`) является отцом Сергея. Во втором случае проверяем, есть ли у Ивана (`иван`) дети.

# Задание 4: Формулировка правила на языке Prolog

```prolog
дети_жены(Дети, Жена) :- 
    родитель_ребёнок(Родитель, Дети),
    женат(Родитель, Жена).
```

### Объяснение:
Правило гласит, что если у кого-то (`Родитель`) есть дети (`Дети`) и он женат на ком-то (`Жена`), то эти дети являются детьми его жены.

# Задание 5: Определение предиката двоюродные_братья/2

```prolog
двоюродные_братья(X, Y) :-
    родитель_ребёнок(РодительX, X),
    родитель_ребёнок(РодительY, Y),
    братья(РодительX, РодительY),
    X \= Y.
```

### Объяснение:
Двоюродные братья (`X`, `Y`) имеют общих родителей (`РодительX`, `РодительY`), которые сами являются братьями, и `X` не равно `Y`.

# Задание 6: Создание базы данных

### Тема: Книги

#### Предикаты фактами
```prolog
автор(харпер_ли, "Убить пересмешника").
жанр("Убить пересмешника", драма).
год_выхода("Убить пересмешника", 1960).

автор(джордж_орвелл, "1984").
жанр("1984", антиутопия).
год_выхода("1984", 1949).
```

#### Предикаты правилами
```prolog
известный_автор(Автор) :-
    автор(Автор, _),
    findall(Год, год_выхода(_, Год), Годы),
    length(Годы, N),
    N > 2.

все_книги_автора(Автор, Книги) :-
    findall(Книга, автор(Автор, Книга), Книги).
```

### Объяснение:
- **известный_автор/1**: Автор считается известным, если у него более двух книг.
- **все_книги_автора/2**: Возвращает все книги данного автора.

# Задание 7: Определение предиката связаны/2

```prolog
связаны(X, Y) :-
    есть_рейс(X, Y).

связаны(X, Y) :-
    есть_рейс(X, Z),
    связаны(Z, Y).
```

### Объяснение:
Предикат `связаны/2` определяет, можно ли попасть из города `X` в город `Y` за один или несколько рейсов. Первое правило проверяет прямой рейс, второе — рекурсивно проверяет наличие промежуточных рейсов.

# Задание 7': Использование рейсов в обоих направлениях

```prolog
связаны(X, Y) :-
    есть_рейс(X, Y);
    есть_рейс(Y, X).

связаны(X, Y) :-
    есть_рейс(X, Z),
    связаны(Z, Y).

связаны(X, Y) :-
    есть_рейс(Y, Z),
    связаны(X, Z).
```

### Объяснение:
Добавлены дополнительные правила для учета рейсов в обоих направлениях.

# Задание 7'': Поддержка циклов

```prolog
связаны(X, Y, Посещенные) :-
    есть_рейс(X, Y),
    not(member(Y, Посещенные)).

связаны(X, Y, Посещенные) :-
    есть_рейс(X, Z),
    not(member(Z, Посещенные)),
    связаны(Z, Y, [Z|Посещенные]).
```

### Объяснение:
Добавлен параметр `Посещенные` для отслеживания посещенных городов и предотвращения зацикливания.
