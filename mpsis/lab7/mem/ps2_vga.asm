| Машинный код    | Ассемблерная инструкция       | Описание поведения                          | Дополнительно                          |
|-----------------|-------------------------------|--------------------------------------------|----------------------------------------|
| `0x030000b7`    | `lui x1, 0x03000`             | Загрузка 0x03000000 в x1                   | x1 = 0x03000000                        |
| `0x07000137`    | `lui x2, 0x07000`             | Загрузка 0x07000000 в x2                   | x2 = 0x07000000                        |
| `0x070011b7`    | `lui x23, 0x07001`            | Загрузка 0x07001000 в x23                  | x23 = 0x07001000                       |
| `0x96018193`    | `addi x1, x1, -1696`          | x1 = x1 - 1696 (0x6A0)                     | x1 = 0x02FFF960                        |
| `0x02400293`    | `addi x5, x0, 36`             | x5 = 0 + 36                                | x5 = 36 (0x24)                         |
| `0x30529073`    | `csrrw x0, mtvec, x5`         | Установка mtvec = x5 (вектор прерываний)   | mtvec = 0x24                           |
| `0x000102b7`    | `lui x5, 0x10000`             | Загрузка 0x10000000 в x5                   | x5 = 0x10000000                        |
| `0x30429073`    | `csrrw x0, mip, x5`           | Попытка записи в mip (флаги прерываний)    | mip обычно read-only → исключение?     |
| `0x00000063`    | `beq x0, x0, 0`               | Бесконечный цикл (условие всегда истинно)  | Останов программы                     |
| `0x0000a383`    | `ld x7, 0xA(x0)`              | Загрузка двойного слова из [x0 + 0xA] в x7 | RV64: x7 = [0xA]                       |
| `0x00038403`    | `lb x8, 0(x7)`                | Загрузка байта из [x7] в x8 (знаковый)     | x8 = sign_extend(Mem[x7][7:0])        |
| `0x00810023`    | `sb x8, 3(x2)`                | Сохранение младшего байта x8 в [x2 + 3]    | Mem[x2 + 3] = x8[7:0]                 |
| `0x00110113`    | `addi x2, x2, 1`              | Инкремент x2 (x2 = x2 + 1)                 | x2 = 0x07000001                       |
| `0x00315463`    | `blt x2, x3, 8`               | Переход на +8, если x2 < x3                | Проверка условия (x3 не инициализирован?) |
| `0x30200073`    | `csrrw x0, 0x302, x0`         | Запись в medeleg (делегирование исключений)| medeleg = 0                            |
| `0x07000137`    | `lui x2, 0x07000`             | Повторная инициализация x2 = 0x07000000    | Сброс x2                              |
| `0x30200073`    | `csrrw x0, 0x302, x0`         | Повторная запись в medeleg                 | medeleg = 0                            |











/* -----------------------------------------------------------------------------
* Project Name   : Architectures of Processor Systems (APS) lab work
* Organization   : National Research University of Electronic Technology (MIET)
* Department     : Institute of Microdevices and Control Systems
* Author(s)      : Andrei Solodovnikov
* Email(s)       : hepoh@org.miet.ru

See https://github.com/MPSU/APS/blob/master/LICENSE file for licensing details.
* ------------------------------------------------------------------------------
*/
_start:
# Инициализируем начальные значения регистров
 0: 030000b7        li x1, 0x03000000           # сохраняем базовый адрес клавиатуры                    420 -1200
 4: 07000137        li x2, 0x07000000           # сохраняем базовый адрес vga-контроллера
 8: 070011b7        li x3, 0x07000960           # количество символов на экране
 c: 96018193                                    # данная псевдоинструкция будет разбита на две
                                                # инструкции: lui и addi
10: 02400293        la x5, trap_handler         # псевдоинструкция la аналогично li загружает число,
                                                # только в случае la — это число является адресом
                                                # указанного места (адреса обработчика перехвата)
14: 30529073        csrw mtvec, x5              # устанавливаем вектор прерывания
18: 000102b7        li x5 , 0x00010000          # подготавливаем маску прерывания единственного
                                                # (нулевого) входа
1c: 30429073        csrw mie, x5                # загружаем маску в регистр маски

# Вызов функции main
main:
20:	00000063        beq x0, x0, main            # бесконечный цикл, аналогичный while (1);

# ОБРАБОТЧИК ПЕРЕХВАТА
# Без стороннего вмешательства процессор никогда не перейдет к инструкциям ниже,
# однако в случае прерывания в программный счетчик будет загружен адрес первой
# нижележащей инструкции.
# Сохраняем используемые регистры на стек
trap_handler:
24: 0000a383        lw x7, 0(x1)                # загружаем сканкод
28: 00038403        lb x8, 0(x7)                # берем данные из таблицы подстановки
2c: 00810023        sb x8, 0(x2)                # загружаем ascii-значение в vga
30: 00110113        addi x2, x2, 1              # инкрементируем адрес vga
34: 00315463        bge x2, x3, wrap_addr       # если адрес vga вышел за границы, то обнуляем
38: 30200073        mret                        # возвращаем управление программе (pc = mepc)
                            # что означает возврат в бесконечный цикл
wrap_addr:
3c: 07000137        li x2, 0x07000000           # сохраняем базовый адрес vga-контроллера
40: 30200073        mret
