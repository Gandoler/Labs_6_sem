// 29 variant
//J  B  WS  const                                   WA
 0  0  00  00000000001000001000101                 00001    // reg[1] = a записываем константу в регист 1                                         вывод нуля

//J  B  WS  comand_const                            WA
 0  0  10  00000000000000000000000                 00010    //reg[2] = sw_i записали со входа                                                     вывод нуля

//J  B  WS  const                                   WA
 0  0  00  00000000000000000000111                 00011    // reg[3] = записываем маску                                                          вывод нуля

//J  B  WS  const                                   WA
 0  0  00  11111111111111111111111                 00100    // reg[4] = переменная переноса будет и будет -1 в начале                             вывод нуля

 //J  B  WS  const                                   WA
 0  0  00  00000000000000000000000                 00101    // reg[5] = правые 3 бита a в данный момент будет                                     вывод нуля

//J  B  WS  const                                   WA
 0  0  00  00000000000000000000001                 00110    // reg[6] = 1 для счетчика                                                            вывод нуля

//J  B  WS  const                                   WA
 0  0  00  00000000000000000000000                 00111    // reg[7] = tmp будет                                                                 вывод нуля

//J  B  WS  const                                   WA
 0  0  00  00000000000000000000000                 01000    // reg[8] = answer                                                                    вывод нуля

//J  B  WS  const                                   WA
 0  0  00  00000000000000000000011                 01001    // reg[9] =  для переноса на 3                                                        вывод нуля

//J  B  WS  const                                   WA
 0  0  00  00000000000000000000000                 01010    // reg[10] = просто константа для нуля                                                вывод нуля

 // ############################################################################################################################################################################################

//J  B  WS  ALUOp   RA1     RA2      comand_const   WA
 0  0  01  00111   00010   00011    00000000       00010 // reg[2] = sw_i & (reg[3])00000000000000000000111 - (правые 3 бит)                              вывод  (reg[2]) - sw_i

//J  B  WS  ALUOp   RA1     RA2      comand_const   WA
 0  0  01  00111   00001   00011    00000000       00101 // reg[5] = a & (reg[3])00000000000000000000111 - (правые 3 бит)                                 вывод  reg[1]) - a


//if
//J  B  WS  ALUOp   RA1     RA2      offset         comand_const
 0  1  01  11000   00010   00101    00001000       00000 // сравниваем a[2:0] и sw_i[2:0] если да то прыгаем на                                   вывод reg[2]- sw_i[2:0]

// нет ############################################################################################################################################################################################

//J  B  WS  ALUOp   RA1     RA2      comand_const   WA
 0  0  01  00000   00100   00110    00000000       00100 // reg[4] = reg[4]+reg[6]  т.е. ++1                                                      вывод  (reg[4]) - переменную переноса

//J  B  WS  ALUOp   RA1     RA2      comand_const   WA
 0  0  01  01101   00001   00110    00000000       00001 // reg[1] =  reg[1]>>1(reg[6])   т.е на 1                                                вывод  (reg[1]) - a

//J  B  WS  ALUOp   RA1     RA2      comand_const   WA
 0  0  01  00111   00110   00001    00000000       00111 // reg[7] = reg[1] & reg[6] - получаем последний бит a                                   вывод  reg[6]) 

//J  B  WS  ALUOp   RA1     RA2      comand_const   WA
 0  0  01  00001   00111   00100    00000000       00111 // reg[7] = reg[7] << reg[4] - сдвигаем на текущую позицию                               вывод  reg[7]) - tmp

//J  B  WS  ALUOp   RA1     RA2      comand_const   WA
 0  0  01  00110   01000   00111    00000000       01000 // reg[8] = reg[8] or reg[7] записываем значение по позиции                              вывод  reg[8]) - answer


//if
//J  B  WS  ALUOp   RA1     RA2      offset         comand_const
 0  1  01  11001   00001   01010    11111101       00000 // сравниваем a и 0 если a!=0 прыгаем обратно на команду получения правых 3 бит a        вывод reg[1]

// если нет 
//J  B  WS  ALUOp   RA1     RA2      comand_const   WA
 1  0  00  00000   01000   00000    00000000       00000 // бесконечный вывод 8 регистра                                                          вывод reg[8]


// да ############################################################################################################################################################################################


//J  B  WS  ALUOp   RA1     RA2      comand_const   WA
 0  0  01  01101   00001   01001    00000000       00001 // reg[1] =  reg[1]>>3(reg[9])                                                           вывод  (reg[1]) - a


//if
//J  B  WS  ALUOp   RA1     RA2      offset         comand_const
 0  1  01  11001   00001   01010    11110110       00000 // сравниваем a и 0 если a!=0 прыгаем обратно на команду получения правых 3 бит a        вывод reg[1]

// если нет 
//J  B  WS  ALUOp   RA1     RA2      comand_const   WA
 1  0  00  00000   01000   00000    00000000       00000 // бесконечный вывод 8 регистра                                                          вывод reg[8]

