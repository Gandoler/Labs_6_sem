# эта операция нужна если мы захотим передать в регситр x15 число которое больше 12 бит и пусть число будет 0000_1111_1111_0111_0110_0010 тогда надо будет 0000_1111_1111_загрузить через 
# lui , а оставшуюся часть добавить позже 0111_0110_0010 = 
lui x15, 0xFF         # x15 = 0000_1111_1111_загрузить
addi x15, x15, 0x762   # x15 += 0111_0110_0010 =0000_1111_1111_0111_0110_0010
sw x15, 0x0(x0) #загружаем так как в задаче требуется Найти количество нулей в двоичном представлении числа sw_i, а sw_i а данном контексте мы не располагаем на момент 6 лабы поэтому будем как бы считывать из памяти




addi x1, x1, 0x0     # x1 = 0: out = 0; т.е. просто регистр для счетчика
# x2 = sw_i (входные данные, изначально 0)
lw   x2, 0(x0)         # x2 = sw_i загрузка sw_i
addi x3, x3, 0x1	# тут будет хранится константа 1 для сдвигов и счетчика 
addi x4, x4, 0x0	# инициализация тут будем хранить последний бит sw_i числа для проверки с нулем 



loop_start:
beq x2, x0, output_loop			# т.е если нолю будет равно входное число мы уходим в вечный луп где будет через такт выводится ответ (можно было его и просто в память вбить)
and x4, x2, x3					# как раз вырезаем последний бит 
bne x4, x0, scip_plus_plus 		#  если не ноль тогда перепрыгиваем увеличение счетчика
addi x1,x1,0x1
scip_plus_plus:
srl x2, x2, x3         # x1 = x1 >> 1
jal x0, loop_start		# вначало цикла






output_loop:
add x1,x1,x0
jal x0, output_loop # Бесконечный цикл (переход на метку output_loop)
