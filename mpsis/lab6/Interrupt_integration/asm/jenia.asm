# addi x15, x0, 0x00000501   # для ввода в памятть - нельзя

lui x15, 0x0        # x15 = 0x0 -----это для случая если хотим задать число больше 4 бит так как правое число 8 бит а вся константа 12
addi x15, x15, 0x505 # x15 += const
sw    x15, 0x0(x0) #загружаем

# Инициализация констант
addi x1, x0, 1      # reg[1] = 1 (a)
addi x5, x0, 8      # reg[5] = 8 (сдвиг)

# Чтение входных данных
lw   x2, 0(x0)      # reg[2] = sw_i (предполагаем, что вход по адресу 0)

# Вычисление d (старшие биты)
srli x3, x2, 8      # reg[3] = sw_i >> 8 (d)

# Настройка маски
addi x5, x0, 0x00FF # reg[5] = 0x00FF (маска)
and  x4, x2, x5     # reg[4] = sw_i & 0xFF (n)

# Инициализация вспомогательных регистров
addi x6, x0, 1      # reg[6] = 1 (константа)
addi x2, x0, 0      # reg[2] = 0
addi x5, x0, 0      # reg[5] = 0

loop_prep:
sub  x4, x4, x6     # n = n - 1

loop:
add  x5, x5, x4     # reg[5] += n (аккумулятор)
sub  x3, x3, x6     # d = d - 1
bgt  x3, x0, loop   # if d > 0, повторить цикл

# Финальное вычисление
add  x1, x1, x5     # a = a + (n-1)*d

# Бесконечный вывод результата
end_loop:
jal  x0, end_loop    # Бесконечный цикл
