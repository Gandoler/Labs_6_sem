00:  addi  x1,  x0, 0x75С       //  Загружает в регистр x1 значение 0x75C (1884 в десятичной системе).                                              1        (0x75C00093)
04:  addi  x2,  x0, 0x8A7       //  Загружает в регистр x2 значение 0x8A7 (-1881 в десятичной системе).                                             2        (0x8A700113)
08:  add   x3,  x1, x2          //  Складывает значения x1 (1884) и x2 (-1881), результат (0x03 или 3) записывает в x3                              3        (0x002081B3)
0C:  and   x4,  x1, x2          //  Побитовое И между x1 (0x75C) и x2 (0xfffff8A7), результат (0x04) записывается в x4.                             4        (0x0020F233)  
10:  sub   x5,  x4, x3          //  Вычитает x3 (3) из x4 (0x04 = 4), результат (1) записывается   в x5                                             5        (0x403202B3)
14:  mul   x6,  x3, x4          //  неподдерживаемая инструкция                                                                                     6        (0x02418333)                                                       
18:  jal   x15, 0x00050         //  Безусловный прыжок на адрес 0x68 (80 в десятичной системе), сохраняя адрес возврата (0x1C) в x15                7        (0x050007EF)
1C:  jalr  x15, 0x0(x6)         //  Прыжок на адрес, хранящийся в x6 (0x80580C), сохраняя адрес возврата (0x20) в x15.Опасная инструкция,x6 null             (0x000307E7)  
20:  slli  x7,  x5, 31          //  Логический сдвиг влево x5 (0xFFFFF801) на 31 бит, результат (0x80000000) записывается в записывается в x7       9        (0x01F29393) 
24:  srai  x8,  x7, 1           //  Арифметический сдвиг вправо x7 (0x80000000) на 1 бит, результат (0xC0000000) записывается в x8
28:  srli  x9,  x8, 29          //  Логический сдвиг вправо x8 (0xC0000000) на 29 бит, результат (0x6) записывается в x9
2C:  lui   x10, 0xfadec         //  Загружает в старшие 20 бит x10 значение 0xFADEC000
30:  addi  x10, x10,-1346       //  Добавляет к x10 (0xFADEC000) значение -1346, результат (0xFADEBABE) записывается в x10
34:  sw    x10, 0x0(x4)         //  Сохраняет слово (x10 = 0xFADEBABE) по адресу x4 (0x804
38:  sh    x10, 0x6(x4)         //  Сохраняет полуслово (младшие 16 бит x10 = 0xBABE) по адресу x4 + 6 (0x80A)
3C:  sb    x10, 0xb(x4)         //  Сохраняет байт (младший байт x10 = 0xBE) по адресу x4 + 11 (0x80F)
40:  lw    x11, 0x0(x4)         //  Загружает слово из 0x804 (0xFADEBABE) в x11
44:  lh    x12, 0x0(x4)         //  Загружает полуслово (знаковое) из 0x804 (0xBABE) в x12
48:  lb    x13, 0x0(x4)         //  Загружает байт (знаковый) из 0x804 (0xBE) в x13
4С:  lhu   x14, 0x0(x4)         //  Загружает полуслово (беззнаковое) из 0x804 (0xBABE) в x14
50:  lbu   x15, 0x0(x4)         //  Загружает байт (беззнаковый) из 0x804 (0xBE) в x15                                                               
54:  auipc x16, 0x00004         //  Загружает в x16 значение PC + (0x00004 << 12)   PC = 0x54, то x16 = 0x54 + 0x4000 = 0x4054                       
58:  bne   x3,  x4, 0x08        //  Если x3 (4099) ≠ x4 (4095), то прыжок на PC + 0x08 (к инструкции 0x60).                                          
5С:                             //  нелегальную нулевую инструкцию
60:  jal   x17, 0x00004         //  Прыжок на PC + 4 (0x64), сохраняя адрес возврата (0x64) в x17
64:  jalr  x14, 0x0(x17)        //  Прыжок на адрес, хранящийся в x17 (0x64), сохраняя адрес возврата (0x68) в x14
68:  jalr  x18, 0x4(x15)        //  Прыжок на адрес x15 + 4 (0x1C + 4 = 0x24), сохраняя адрес возврата (0x6C) в x18                                 8        (0x00478967)



