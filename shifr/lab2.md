# **Лабораторная работа №2: Шифрование и расшифровывание RSA**

## **Теоретическая часть**

### **Описание RSA**
RSA — это криптографический алгоритм с открытым ключом. В нем используются два ключа:  
- **Открытый ключ** (передается всем и используется для шифрования).  
- **Закрытый ключ** (держится в секрете и используется для расшифрования).  

Отправитель шифрует сообщение открытым ключом получателя, а получатель расшифровывает его своим закрытым ключом.  

### **Процедура создания ключей RSA**
1. Выбираются два простых числа `p` и `q`, например `p = 7`, `q = 13`.
2. Вычисляется `n = p * q`, в нашем случае `n = 7 * 13 = 91`.
3. Вычисляется функция Эйлера `φ(n) = (p-1) * (q-1)`, для примера `φ(91) = (7-1) * (13-1) = 72`.
4. Выбирается число `e`, такое что `0 < e < φ(n)` и `e` взаимно просто с `φ(n)`. Например, `e = 5`. Пара `(e, n)` — это открытый ключ.
5. Вычисляется `d`, такое что `(d * e) mod φ(n) = 1`. В примере `d = 29`. Пара `(d, n)` — это закрытый ключ.

### **Шифрование и расшифровка**
- **Шифрование**:  
  Каждая буква сообщения заменяется на число `T` и шифруется по формуле:  
  ```C
  C = (T ^ e) mod n
  ```
- **Расшифровка**:  
  Полученное `C` расшифровывается по формуле:  
  ```C
  T = (C ^ d) mod n
  ```

## **Практическая часть**

### **Обзор кода**
В проекте есть два основных класса:  
- **Recipient** (получатель, который генерирует ключи и расшифровывает сообщения).  
- **Sender** (отправитель, который шифрует сообщения).  

### **Разбор алгоритмов**

#### **1. Алгоритм Евклида**
Используется в функции `GCD(int a, int b)`, чтобы найти **наибольший общий делитель (НОД)**.  
Принцип работы:
1. Делим большее число на меньшее и берем остаток.
2. Если остаток 0 — нашли НОД.
3. Иначе продолжаем процесс с остатком.

Пример:  
Находим `НОД(30, 18)`:
```
30 % 18 = 12
18 % 12 = 6
12 % 6 = 0 → НОД = 6
```

#### **2. Расширенный алгоритм Евклида**
Используется в `GetD()`, чтобы найти `d`, обратное `e` по модулю `φ(n)`.  
Принцип:  
- Расширенный алгоритм Евклида не только находит НОД, но и коэффициенты `x` и `y`, такие что:  
  ```
  a * x + b * y = НОД(a, b)
  ```
- В RSA нам нужно `d`, такое что:  
  ```
  (d * e) mod φ(n) = 1
  ```
- Мы представляем `d` как `x` из расширенного алгоритма Евклида.

Пример:  
Найдем `d`, если `e = 5` и `φ(n) = 72`:
```
72 = 5 * 14 + 2
5 = 2 * 2 + 1
2 = 1 * 2 + 0
```
Обратный ход:  
```
1 = 5 - 2 * 2
1 = 5 - (72 - 5 * 14) * 2
1 = 5 * 29 - 72 * 2
```
Значит, `d = 29`.

#### **3. Быстрое возведение в степень по модулю**
Используется в `ModularExponentiation()`.  
Принцип:
- Мы заменяем `a^b mod m` на последовательные возведения в квадрат и умножения.  
- Это делает вычисления быстрее.

Пример:  
Вычислим `7^13 mod 11`:  
```
7^13 = 7^(8+4+1) = (7^8 * 7^4 * 7^1) mod 11
```
По шагам:
```
7^2 mod 11 = 49 mod 11 = 5
7^4 mod 11 = (7^2)^2 mod 11 = 5^2 mod 11 = 25 mod 11 = 3
7^8 mod 11 = (7^4)^2 mod 11 = 3^2 mod 11 = 9
```
```
7^13 mod 11 = (9 * 3 * 7) mod 11 = 189 mod 11 = 2
```

---

### **Структура кода**
#### **Recipient.cs**
- **Генерирует два случайных простых числа `p` и `q`.**
- **Находит `n` и `φ(n)`.**
- **Выбирает `e`, проверяя, чтобы `НОД(e, φ(n)) = 1`.**
- **Находит `d` с помощью расширенного алгоритма Евклида.**
- **Расшифровывает сообщение, применяя быстрое возведение в степень.**

#### **Sender.cs**
- **Шифрует сообщение, используя открытый ключ `(e, n)`.**
- **Каждый символ переводит в число и возводит в степень по модулю `n`.**

---

<img width="1512" alt="image" src="https://github.com/user-attachments/assets/777e5488-6712-461b-9be7-3acdff31b154" />

---
