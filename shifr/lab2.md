# Лабораторная работа №2: Шифрование и расшифровывание RSA

## Теоретическая часть

### Описание RSA
RSA относится к асимметричным шифрам. В таких шифрах используются два ключа – открытый и закрытый, которые создаются получателем сообщения. Открытые ключи доступны всем желающим и передаются по незащищённому каналу связи. Отправляемое сообщение шифруется открытым ключом получателя и дешифрируется закрытым ключом при его получении. 

### Процедура создания ключей RSA
1. Выбираются два простых числа `p` и `q`, например `p = 7` и `q = 13`.
2. Вычисляется произведение `n = p * q`. В нашем примере `n = 7 * 13 = 91`.
3. Вычисляется функция Эйлера `φ(n) = (p-1) * (q-1)`. В нашем примере `φ(n) = (7-1) * (13-1) = 72`.
4. Выбирается произвольное целое `e`: `0 < e < n`, взаимно простое со значением функции Эйлера `φ(n)`. В нашем примере возьмём `e = 5`. Пара чисел `(e, n)` объявляется открытым ключом шифра.
5. Вычисляется целое число `d` из соотношения `(d * e) mod φ(n) = 1`. В нашем примере `d = 29`.

### Шифрование и расшифровывание RSA
Шифрование сообщения `T` выполняется с помощью открытого ключа получателя `(e, n)` по формуле:

```
C_i = (T_i^e) mod n
```

Расшифровка RSA-закодированного сообщения `T` выполняется с помощью закрытого ключа получателя `(d, n)` по формуле:

```
T_i = (C_i^d) mod n
```



### **Используемые алгоритмы**

#### **1. Алгоритм Евклида (поиск НОД)**
Используется в методе `GCD(int a, int b)`, чтобы проверить, является ли `e` взаимно простым с `φ(n)`.  

**Пример**: Найдём **НОД(72, 5)**  
1. 72 / 5 = 14, остаток **2**
2. 5 / 2 = 2, остаток **1**
3. 2 / 1 = 2, остаток **0** → **НОД = 1**  

```csharp
private int GCD(int a, int b)
{
    while (b != 0)
    {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
```
Если `НОД(e, φ(n)) == 1`, то `e` подходит.

---

#### **2. Расширенный алгоритм Евклида (нахождение d)**
Расширенный алгоритм Евклида ищет число `d`, обратное `e` по модулю `φ(n)`, то есть:

\[
(d * e) \mod φ(n) = 1
\]

**Пример**: Найдём `d`, обратное `5` по `φ(n) = 72`.  
Решаем уравнение:

\[
5d \equiv 1 \mod 72
\]

Используем расширенный алгоритм Евклида:

| Шаг | `φ(n)` | `e` | Частное | Остаток | `x1` | `x2` | `d`  |
|------|-------|---|--------|--------|----|----|----|
| 1    | 72    | 5 | 14     | 2      | 0  | 1  | 1  |
| 2    | 5     | 2 | 2      | 1      | 1  | -14| -14 |
| 3    | 2     | 1 | 2      | 0      | -14| 29 | 29 |

`d = 29`  

```csharp
private int GetD()
{
    int d = 0, x1 = 0, x2 = 1, y1 = 1, tempPhie = phie, tempE = e;
    while (tempE > 0)
    {
        int temp = tempPhie / tempE;
        int remainder = tempPhie % tempE;
        tempPhie = tempE;
        tempE = remainder;
        int x = x2 - temp * x1;
        x2 = x1;
        x1 = x;
        int y = d - temp * y1;
        d = y1;
        y1 = y;
    }
    return d + (d < 0 ? phie : 0); // Убедимся, что d > 0
}
```
Если `d` оказалось отрицательным, мы прибавляем `φ(n)`.

---

#### **3. Быстрое возведение в степень по модулю**
Используется в `ModularExponentiation(int baseNum, int exp, int mod)`,  
чтобы вычислять:

\[
(a^b) \mod c
\]

**Пример**: \(3^{10} \mod 13\)

**Пошаговое вычисление**:
1. \(3^1 = 3 \mod 13 = 3\)
2. \(3^2 = 9 \mod 13 = 9\)
3. \(3^4 = (3^2)^2 = 81 \mod 13 = 3\)
4. \(3^8 = (3^4)^2 = 9\)
5. \(3^{10} = 3^8 \times 3^2 = 9 \times 9 = 81 \mod 13 = 3\)

**Код**:
```csharp
private static int ModularExponentiation(int baseNum, int exp, int mod)
{
    int result = 1;
    baseNum = baseNum % mod;

    while (exp > 0)
    {
        if ((exp & 1) == 1) 
            result = (result * baseNum) % mod;

        exp = exp >> 1; 
        baseNum = (baseNum * baseNum) % mod;
    }

    return result;
}
```
Этот метод работает за \( O(\log b) \) вместо \( O(b) \), что значительно быстрее.

---


Этот подход **эффективен**, так как все основные операции выполняются за **логарифмическое время** относительно входных чисел.


<img width="1512" alt="image" src="https://github.com/user-attachments/assets/777e5488-6712-461b-9be7-3acdff31b154" />

